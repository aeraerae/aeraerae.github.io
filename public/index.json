[{"content":" 나는 병신이다. 너무 작은 우물에 갇혀 살았다. 최근에는 뇌에 구멍이라도 난 게 아닌가 생각이 들 정도로 멍청한 짓만 하고 있다.\n나는 고등학교 때 제2외국어 대신 정보과학 과목을 선택해서, 학교에서 코딩과 알고리즘을 겉핥기 수준으로 배웠다. 나는 그 당시 백엔드 개발자에 관심이 많았고, JavaScript나 파이썬을 쥐좆만큼 할 줄 알아서 꽤나 좋은 성적을 거뒀다. 나는 코딩에 자신감이 붙어서 대학교도 컴공이 아니면 안 가겠다고 땡깡을 부려, 좋지 않은 가정 형편임에도 불구하고, 지방대 떨어진 성적으로 재수를 했다.\nPS는 대학교에 입학하기 전 겨울방학에 시작했다. 대가리가 깨지는 경험을 50번을 넘게 해도 여전히 어렵다. 나는 사실 DP를 할 줄 모른다. 내가 못 하면 그냥 도망친다. 정말 병신이다. 최근에는 코드포스 하다가 개빡쳐서 마우스를 집어던졌다가 아끼던 넨도를 깨먹었고\u0026hellip;ㅋㅋ 아니 딥4 C번을 못 풀면서 꿈은 블루인 새끼가 할 만한 행동이지 뭐. 요즘은 DP 비슷한 것만 나오면 병신이 돼서 테이저건 쳐맞은 새끼마냥 아무것도 못한다. 걍 씨발 개 좆같아서 비밀번호 바꾸고 로그아웃 함. 다신 안 한다 ㅂㅂ\n우리 학교에는 PS 동아리가 하나 있다. AlKon이라고, 멋진 분들이 이끌어 주셨지만, 다들 하나둘씩 졸업하신다. 작년 회장님께서는 휴학을 하시고, 회장 자리가 비어버렸다. 동아리에서 가장 PS를 잘 하는 yookwi는 올해 군대를 간다. motsuni04는 불확실하고. 나는 2학기에 입대할 예정이었지만, 공군가서 개꿀빨 생각에 그냥 내년으로 미뤄버렸고, 회장 할 사람이 아무도 없어서 내가 하기로 했다. 존나 옹졸해진다 ㅋㅋ 진짜 와\u0026hellip; 올해 정말 어떻게 될 지 모르겠다. 1학기에는 yookwi랑 motsuni04가 잘 해주겠지.\n작년 ICPC에 함께 나갔던 저 둘은 나에게 과분한 친구들이다. 같이 PS를 하고 있으면 지능의 벽만 더 느껴진다. 최근 같이 출제를 하고 있는데, 내가 만든 문제는 다 하나같이 꼼꼼하지 못해 병신같은 풀이가 통과되거나 개병신같은 반례가 끝도 없이 쳐나온다. 방금 전까지 yookwi가 밤새서 내 문제 똥 치워줬다. 얘가 이상하게 못 풀면 내 문제가 잘못된 거더라.\n최근에는 수면 패턴이 완전히 망가졌다. 병신 루저새끼마냥 남을 피해 다른 시간대로 도망쳤을 뿐이다 ㅋ\n컴공 나와서 돈 버는 건 이제 포기했다. 돈 생각하기 싫다. 뭐 친구는 퀀트 회사 가겠다고 지랄하는데, 미안 솔직히 그거 존나 힘들걸. 진지하게 자퇴하고 재수학원 들어가서 메디컬이나 준비할까 했는데 내 지능으로는 안된다. 그냥 하고 싶어서 한 짓 끝까지 가보기로 했다. 내가 죽는다면 GPT가 날 굶겨죽였거나 지능 이슈로 ^자연사^ 했겠지.\n","permalink":"http://localhost:1313/posts/no-title/","summary":"나는 병신이다. 너무 작은 우물에 갇혀 살았다. 최근에는 뇌에 구멍이라도 난 게 아닌가 생각이 들 정도로 멍청한 짓만 하고 있다.\n나는 고등학교 때 제2외국어 대신 정보과학 과목을 선택해서, 학교에서 코딩과 알고리즘을 겉핥기 수준으로 배웠다. 나는 그 당시 백엔드 개발자에 관심이 많았고, JavaScript나 파이썬을 쥐좆만큼 할 줄 알아서 꽤나 좋은 성적을 거뒀다. 나는 코딩에 자신감이 붙어서 대학교도 컴공이 아니면 안 가겠다고 땡깡을 부려, 좋지 않은 가정 형편임에도 불구하고, 지방대 떨어진 성적으로 재수를 했다.","title":"무제"},{"content":"Intro 원래는 UCPC 2024에 도전했다가 뜨거운 실패의 맛을 보고, 팀도 깨져서 올해 ICPC는 포기하고 팀 대회는 군대나 다녀와서 시작할 생각이었습니다. 하지만\u0026hellip;\n우연히 평소 알고만 지내던 AlKon 동아리 2학년 motsuni04에게 연락이 왔습니다. (이 때는 몰랐지만) 작년 ICPC 팀원이었던 s6xybr8in님이 군입대를 하게 되셔서 제가 들어오게 되었습니다. 든든한 버스기사 yookwi도 합류해서 팀이 결성되었습니다!\n팀연습은 보통 업다운 랜디, USACO나 ICPC 기출셋, Codeforces Div.2 등등 다양하게 하였고, 세종대 pizzaroot랑 팀원 분들도 가끔 같이 연습했었습니다. 공강이 겹치는 시간에 PC방에서 같이 Codeforces 버추얼을 쳤던 기억도 나네요 ㅋㅋ\n보통 팀연습을 하면 yookwi가 문제가 구데기같다면서 투덜거리며 가장 먼저 풀고, 구현이 빠른 motsuni04가 따라 풀고, 저는 대부분 못 풀어서 팀원들에게 배우거나 풀어도 가장 늦게 풀었습니다.\n팀연습에서 가장 어려웠던 점은 대회 환경으로 인해 C++이 강제되었다는 것인데요, 저는 주력 언어가 Rust였고, C++ 특유의 불친절한 디버깅과 Undefined Behavior지만 돌아가긴 해서 생기는 문제들의 대환장 콜라보로 정말 많이 힘들었습니다. (변명 아님)\n그래도 같이 연습하는 동안 DP와 이분탐색 등 기본적인 실력이 많이 늘었고, 문제를 바라보고 해결하는 인사이트도 늘었습니다. 또, 구현 능력도 좋아진 것 같아서 보람이 있었습니다. 팀 분위기도 좋았던 것 같고 정말 소중한 시간이었습니다.\nBusTaeWarJo라는 팀명은 AlKon 회장님이 정해주신 대회 접수 마감기한 3분 후까지도 정하지 못했다가 막 지었습니다. yookwi가 버스기사입니다.\n온라인 예선 예선은 치른 지 조금 오래됐기도 했고, 제가 정말 버스만 타서 기억도 별로 없어서 간략하게 적겠습니다. 학교 근처에서 점심을 먹고, 편의점에서 대회 중에 먹을 과자를 샀습니다. 원래 학교 K-Cube라는 스터디 룸을 예약했는데, 생각보다 환경이 좋지 않았고, 심지어 근처 교내 프린트 가게가 주말이라 전부 문을 닫아서 재빨리 근처 스터디 카페를 예약해서 장소를 옮겼습니다.\n예선 문제셋 (BOJ)\n어떤 이유에서인지, K번이 아직 안 올라왔습니다. 이곳에서 전 문항 pdf를 볼 수 있습니다.\nE (00:06)\n저는 대회가 시작되자마자 스터디 카페 프린터로 문제지를 인쇄하러 갔습니다. 그 사이 다른 팀원들이 문제지의 한국어 문제가 있는 페이지들을 모아놓고 읽어보다가 가장 쉬워보여서 motsuni04가 빠르게 풀었다고 합니다.\nH (00:35) +1\n마찬가지로 한국어 문제입니다. yookwi가 백트래킹으로 풀었습니다.\nF (00:55)\n이것도 한국어 문제입니다. 누가봐도 기하라 미뤄두려다가, motsuni04가 간단한 풀이를 찾아 빠르게 구현했습니다. 이때쯤 저는 D를 잡고 있었습니다.\nC (01:09)\nyookwi가 종이에 조금 적어보더니, 아는 문제라고 세그먼트 트리와 KMP를 빠르게 구현하여 AC를 받았습니다. 이정도면 본선컷은 넘길 수 있겠다는 생각에 기뻤습니다. 하지만\u0026hellip; (후술)\nG (02:39) +7\n저는 잡고있던 D가 그리디 문제고, 대각선끼리 만나는 교점을 가지고 비벼보면 될 것 같단 생각을 했지만, 팀원들에게 관찰한 내용을 말해주니 2-SAT 같다면서 버리자고 했습니다. 이후 yookwi가 저에게 MST 쓰는 문제 같으니 G번을 잡아보라고 줬지만, 20분동안 별 진전이 없었습니다. 다시 yookwi에게 G번을 넘기고 이때까지 저와 motsuni04는 K번의 상한이 생각보다 널널하다는 점을 관찰해 풀이를 대충 알아냈고, 코드까지 공책에 적었지만 yookwi가 맞왜틀을 하며 테스트 케이스를 만들어주는 데 올인했습니다. 팀노트를 대회 하루 전 yookwi가 정말 대충 만들어왔는데, 정말 운이 좋게도 단절점/단절선 알고리즘이 있어서 유용하게 사용했습니다. 코드를 자잘하게 수정하면서 7번의 시도 끝에 결국 G를 풀고 스코어보드를 보니 30위 안에 들어서 본선 진출이 확정되었습니다. 너무 짜릿했습니다.\n이후 마침 근처에서 예선을 치른 AlKon 회장 dldyou님과 pizzaroot 팀이랑 저녁식사를 했습니다. 양식집이었는데, 피자와 파스타를 정말 맛있게 먹었습니다. 그 다음날 있을 정보보안 동아리 대회에서 출제를 하시게 된 dldyou님과 많이 바쁘셨던 javago님은 먼저 가시고, 나머지는 보드게임 카페에 가서 능지대결을 펼쳤습니다.\n이후 예선 19등으로 마무리하는 줄 알았지만, C번 정해에 이상이 있었다는 것이 발견되고, 재채점 결과 25등으로 마무리하게 되었습니다\u0026hellip; 뭐 본선 진출은 했으니 된 거 아닐까요 ㅎㅎ;\n본선 시험 기간이 끝나고 본 대회를 위해 다시 열심히 연습했습니다. 저는 도널드 커누스의 이산 수학 책인 \u0026lt;구체 수학 (Concrete Mathematics)\u0026gt;과 건국대학교 수학과 정수론 전공서적, 중학교 수학 올림피아드 기출문제들을 통해 살짝 따로 수학을 공부했습니다.\n팀노트도 새로 만들었습니다. 배워야 쓸 수 있는 너무 어려운 알고리즘들은 쳐내고, 실용적으로 구성했습니다.\n예비소집날 저는 합정에서 M7731 버스를 타고 갔는데, 우연히 yookwi를 만나서 같이 갔습니다. 뭔가 학생들처럼 보이는 사람들이 킨텍스 제1전시장쪽으로 가서 속을 뻔 했지만 (다른 행사가 있었나봅니다), 상당히 여유롭게 도착했습니다. ICPC 관련 현수막은 없고 블루 아카이브 3주년 축제 현수막이 대문짝만하게 걸려있어서 잘못 온 줄 알았습니다 ㅎㅎ;\n저기갈걸\n등록을 마치고, 대기실에서 포커, 테트리스, 리듬게임, 롤 등 다양하게 즐기다가 연습 세션 문제를 빠르게 풀고 나왔습니다. 모니터도 아래로 꺾여 있었고, 키보드 키감이 정말\u0026hellip; 최악이라 스탭분께 다이소에서 키보드 하나 사와도 되나 여쭤봤지만 안 된다고 하셨습니다. 인형같은 개인용 토템을 들고 오신 분들도 계셨는데, 반입이 가능한 줄 알았으면 저도 하나 가져올 걸 하는 생각이 듭니다. 참고로 저희 팀은 Visual Studio Code를 사용하기로 했고, 제가 Vim 익스텐션을 켜놨다가 한 대 맞을 뻔 했습니다. CPH (yookwi는 CHP라고 부릅니다) 익스텐션이 없는 게 조금 아쉬웠지만, 그럭저럭 좋았습니다.\n테트리스도 질려서 이제 할 일도 없는데 pizzaroot 팀은 아직 뭔가 열심히 하고 있어서, 제가 장미 접는 법을 yookwi에게 전수해주었고, 결국 둘이서 받은 문제지로 몽땅 장미를 접어놓고 나왔습니다. 예쁘죠? ㅎ\n연습 세션이 끝나고 대회장을 나와서 pizzaroot 팀과 또 저녁을 먹었습니다. 대화역 근처 노랑통닭을 갔는데 치킨으로 정말 배부르게 먹었습니다.\n이후 킨텍스와 조금 떨어져있는 숙소로 가서 짐을 풀고, 근처 홈플러스에서 야식, 다음날 아침에 먹을 크리스피 도넛, 대회 중에 먹을 간식을 샀고 신나게 팀연습 (랜디 잠깐 하다가 앳코더 풀이 시청)도 하고 게임을 하다가 잤습니다. 제가 저녁을 먹었던 노랑통닭집에 휴대폰을 놓고 나오는 앙증맞고 사소한 일이 있었지만 대형 사고는 아니었습니다.\n다음날 아침 motsuni04가 침대에서 이불탐색을 하다가 TLE가 날 뻔한 앙증맞고 사소한 일이 있었지만 원만하게 잘 해결되었고, 택시를 타고 대회장까지 갔습니다. 9300원밖에 안 나왔는데 버스보다 2배 빨랐으니 본전 아닌가 싶습니다.\n다행히 늦지 않게 등록을 마쳤고, yookwi가 작년에 늦게 입장했다가 간식을 받지 못하는 대참사가 발생했다고 앞에 앉자 해서 제일 앞에 앉았습니다. (사실 올해는 간식이 없었고 물만 줬지만요)\n대회장에 가장 들어갔지만, 참가자들이 들어오는 속도가 생각보다 느려서 대회가 연기되었고, 저희 팀은 풍선의 개수, 색깔, 배치와 문제 난이도와의 상관관계를 예측하는 쓰잘데기 없는 짓으로 시간을 떼우다가 (사실 의미가 있었습니다!) 대회가 시작되었습니다. 다행히 키보드는 예비소집때보단 덜 나쁜 사무용 멤브레인 키보드였습니다.\n본선 문제셋 (BOJ)\nA (00:18) +1\n제가 잡은 문제가 되게 쉬워보여서, 쉬운 문제를 빠르게 구현할 수 있는 motsuni04에게 넘겨주었습니다. 구현이 지저분하다고 궁시렁거리면서 1번 틀리고 열심히 반례를 찾다가 결국 AC. 나중에 훨씬 간단한 풀이를 찾았다면서 좋아했습니다. 대회 전 A번 풍선이 ICPC를 상징하는 빨간색, 노란색, 파란색 풍선 중 하나라 A번이 쉬워보인다고 말했었지만, 진짜 가장 쉬운 문제일 줄은 상상도 못했습니다\u0026hellip;\nB (00:34) +1\n이 문제는 제가 잡다가 그리디인 줄 알고 삽질했는데, yookwi가 가져가서 빠르게 풀었습니다. 살다살다 이런 구현을 다 해본다고 하길래 나중에 알아보니 맵을 가지고 BFS를 돌리는 풀이를 짜냈다고 합니다 ㅋㅋ.\nL (01:03)\n이 문제도 처음에는 제가 잡았다가, 상위권 팀이 너무 빨리 풀어버려서, 새로운 삼각형을 만들 수 있는 격자점들이 $\\gcd (\\vert x_i - x_j \\vert, \\vert y_i - y_j \\vert)$의 배수만 가능하다는 당연한 관찰과 함께 motsuni04에게 넘겨주었습니다. 구현을 잘 해서 다행히 한 번에 맞았습니다. 나중에 들어보니 yookwi가 풀이를 대부분 완성했다고 합니다.\nJ (01:50) +2\nyookwi와 motsuni04 둘이 풀었습니다. 맞왜틀을 하면서 많이 고생했던 것으로 기억합니다. 저는 E를 풀었고, yookwi에게 풀이를 설명했지만, 처음에 다익스트라를 쓸 생각을 해서 시간 안에 안 돌거라고 빠꾸를 먹고, 나중에 다시 각 꼭짓점에서 S, T까지의 최단 경로를 수학으로 구할 수 있다고 말했지만, Convex Hull까지 구현에 동원하기가 쉽지 않아 2빠꾸를 먹고 미뤄두기로 했습니다.\nF (03:01) +2\nyookwi의 오더로 저와 motsuni04가 손으로 직접 $n$이 작을 때를 직접 해보면서 규칙성을 찾아봤습니다. 처음에는 귀납적으로 증명할 수 있나 했지만, $0.7(n+1)^2 - 0.7n^2 = 1.4n + 0.7$, $n$번째가 정렬된 상태로 $n+1$ 페어를 추가해도 제한 안에 옮길 수 없다는 것을 확인했습니다. motsuni04가 꽤 적은 횟수로 정렬하는 데 성공했지만, 일관적으로 풀 수 없어서 한참을 더 잡고 있었고, 제가 기적적으로 지그재그로 원소 $1$하나를 $1$번 인덱스에 갖다넣으면 이쁜 모양이 나오는 것을 관찰해서 yookwi에게 넘겨주었습니다. yookwi가 생각보다 빠르게 구현했지만, WA를 받았습니다. 셋이서 한참 디버깅을 한 후에, yookwi가 결국 문제점을 찾았습니다. swap 연산을 하기 전에 과정을 출력했어야 하지만, swap 연산 이후에 출력을 해버려서 틀렸던 것이었습니다. 코드 두 줄의 순서만 바꿔서 AC를 받았습니다. 생각보다 종이에 쓸 게 많아서 풀고나서 손이 조금 아팠습니다.\n이후로는 계속 C를 열심히 잡다가 TLE가 나올 각오로 제출해보았지만 신기하게 WA를 받았고, E에 미련이 남은 제가 별찍기 코드를 제출해서 WA를 받고 5솔브 38위라는 조금 아쉬운 성적으로 대회가 종료되었습니다.\n온사이트 대회 최고의 관람 포인트는 스코어보드 오픈이 아닐까 싶습니다. 저희 팀이 나올 때만 빼고 역전과 재밌는 포인트들이 많이 나와 박수와 환호가 터져나왔던 것 같습니다.\n풀이 세션과 Tech Talk 등 남은 일정들이 마무리되고, 같이 저녁식사를 하고 각자 집 가는 길이 달라서 헤어졌습니다. 마침 블루 아카이브 축제가 끝나는 시간과 겹쳐서\u0026hellip; 매우 지옥같은 킨텍스 교통을 맛볼 수 있었습니다.\n이 글을 작성하고 있는 지금도 저는 대회 준비했을 때만큼 열심히 알고리즘 공부를 하고 있습니다. 문제를 봐도 접근조차 하지 못해 팀원에게 떠넘기기만 하고, 잘 하지 못해 팀원들에게 너무 미안했습니다. 정말 팀명대로 제가 버스를 타버린 것입니다. 분명 AlKon 동아리에 저보다 잘 하는 분들도 많은데, 한편으론 불러줘서 고마웠고, 연습 내내 배우면서 성장할 수 있어서 좋았습니다. 정말 잊지 못할 즐거운 경험이었던 건 분명합니다.\n저는 내년에 2학년 1학기를 마치고 입대를 할 예정입니다. 군대에서도 꾸준히 알고리즘을 공부해서 2, 3, 4학년때 ICPC에서 지금보다 더 좋은 성적을 받아 꼭 입상하고 싶습니다. 아무튼 긴 글 읽어주셔서 감사합니다.\n","permalink":"http://localhost:1313/posts/icpc-2024-seoul/","summary":"Intro 원래는 UCPC 2024에 도전했다가 뜨거운 실패의 맛을 보고, 팀도 깨져서 올해 ICPC는 포기하고 팀 대회는 군대나 다녀와서 시작할 생각이었습니다. 하지만\u0026hellip;\n우연히 평소 알고만 지내던 AlKon 동아리 2학년 motsuni04에게 연락이 왔습니다. (이 때는 몰랐지만) 작년 ICPC 팀원이었던 s6xybr8in님이 군입대를 하게 되셔서 제가 들어오게 되었습니다. 든든한 버스기사 yookwi도 합류해서 팀이 결성되었습니다!\n팀연습은 보통 업다운 랜디, USACO나 ICPC 기출셋, Codeforces Div.2 등등 다양하게 하였고, 세종대 pizzaroot랑 팀원 분들도 가끔 같이 연습했었습니다. 공강이 겹치는 시간에 PC방에서 같이 Codeforces 버추얼을 쳤던 기억도 나네요 ㅋㅋ","title":"2024 ICPC Seoul Regional 후기"},{"content":"Intro 이분 탐색 알고리즘은 컴퓨터 공학을 전공하지 않더라도 누구나 교양 시간에 배워봤을 만한 알고리즘입니다. 이분 탐색의 개념 자체는 직관적이지만 응용이 상당히 어렵습니다. 오늘은 이분 탐색과 그 활용에 대해 다뤄보겠습니다. 이분 탐색이란? 이분 탐색이 정확히 무엇일까요? 이분 탐색의 예시로 보통 업-다운 게임을 많이 사용하는데요, 진행자는 $1$부터 $100$까지의 정수 중 하나를 고르고, 질문자는 이 정수를 맞혀야 합니다. 질문자는 매 질문마다 정수를 하나 골라 질문하고, 진행자는 질문자가 고른 정수와 진행자가 고른 정수의 대소관계만을 대답해줍니다. 최소 횟수의 질문을 가지고 정답을 맞히고 싶다면, 어떤 전략을 취해야 할까요?\n당신이 질문자라면, 맨 처음 $50$을 선택하고, 결과에 따라 계속 절반씩 줄여나가는 전략을 취하는 것이 합리적일 것입니다.\n그러나 이 예시는 이분 탐색의 개념을 설명할 때 유용하겠지만, 업-다운 게임은 이분 탐색의 한 예시일 뿐, 실제로는 더 일반화된 방식으로 구현합니다.\n탐색 범위가 추상적입니다.\n$1$부터 $N$까지의 정수를, 정렬된 정수 배열 $A = [1, 2, \\cdots, N]$로 먼저 환원시킨 후 생각해야 합니다.\n종료 조건이 일반적이지 않습니다.\n업-다운 게임에서는 찾으려는 값과 중앙값이 일치할 때 종료하지만, 일반적인 이분 탐색 구현에서는 그렇게 하지 않습니다. (만약 찾으려는 수가 배열에 없으면 어떻게 될까요? 무한 루프에 빠질 것입니다.) 그렇다면, 이분 탐색을 어떻게 정의해야 할까요?\n정렬된 배열에서 \u0026lsquo;예/아니오\u0026lsquo;로 답할 수 있는 질문 $Q(m)$ (단, $m$은 중앙값)에 대하여 $Q(m)$의 답이 참인 구간과 거짓인 구간의 경계를 찾는 것 으로 정의합시다. 이분 탐색을 매개 변수 탐색의 정의로 환원시킨 것입니다. 이제 이분 탐색은 단순히 탐색 범위를 반씩 줄여주는 역할만 하는 것이 아니라, 최소/최대를 구하는 최적화 문제를 빠르게 해결할 수 있는 도구가 될 수 있습니다.\n이분 탐색의 구현 최적화 문제를 다루기에 앞서, 우선 이분 탐색이 어떻게 작동하는지 알아봅시다. 이분 탐색은 다음과 같은 Python 코드로 표현할 수 있습니다.\ndef Q(x: int) -\u0026gt; bool: # 질문 Q(x)에 대한 답을 계산해서 리턴 return (condition); left = 0 right = N + 1 while left + 1 \u0026lt; right: mid = (left + right) // 2; # 중앙은 floor로 구함 if Q(mid): left = mid else: right = mid 편의상 0이상 left이하에 위치하는 구간이 condition을 만족하고, right이상 N + 1이하에 위치하는 구간이 condition을 만족하지 않는다고 합시다. while (left + 1 \u0026lt; right) 때문에 left와 right가 인덱스 1 차이로 맞닿을 때까지 반복하며 탐색할 구간을 반씩 줄입니다.\n아까 예시로 들었던 업-다운 게임을 살짝 변형해 봅시다. $1$부터 $N=10$까지 정수를 가지고, 진행자가 $7$을 생각했다고 해봅시다. 진행자가 생각한 최소한의 정수가 얼마인지 찾는 최적화 문제를, 결정 문제들의 조합들로 재구성 해봅시다.\n질문 $Q(x)$를 \u0026ldquo;$x$ 미만인가?\u0026ldquo;로 정의합시다. $Q(x)$가 작은 정수에 대해선 True였다가, 점점 큰 수를 넣다 보면 어느 순간 False를 반환할 것입니다. 이분 탐색의 목적은 바로 이 경계를 찾아내는 것입니다. 먼저, left = 0, right = 11로 놓습니다. 만약, 진행자가 $1$ 또는 $10$을 생각했더라도 left 구간과 right 구간의 경계를 명확하게 정의하기 위해 임의로 확장했습니다.\n중앙값 mid는 $\\textrm{mid} = \\lfloor \\frac{\\textrm{left} + \\textrm{right}}{2} \\rfloor$, 정수 나눗셈은 버림으로 구현합니다. a[mid] = 5 입니다. $5 \u0026lt; 7$ 이므로 진행자는 \u0026lsquo;down\u0026rsquo;을 대답했을 것입니다. 따라서 질문 $Q(5)$의 답은 True가 되고, 배열이 정렬되어 있기 때문에, mid보다 앞 인덱스에 있는 정수들은 볼 필요도 없이 True인 구간에 포함됩니다. 따라서, mid는 left구간에 포함되어야 합니다.\n이제 다시 mid를 새로 잡아봅시다.\na[mid] = 8입니다. $Q(8)$의 답은 $7 \\le 8$이므로 False가 됩니다. 이번에는 mid가 right구간에 포함되어야겠죠?\n종료될 때까지 반복합시다. 중앙값을 잡고 $Q(\\textrm{mid})$가 True인지 False인지 비교합시다. a[mid] = 6이고, $Q(6)$의 답은 $6 \u0026lt; 7$이므로 True입니다. left구간에 mid를 포함시켜줍시다.\n마지막 비교입니다. a[mid] = 7이고, $7 \\le 7$이므로 $Q(7)$은 False를 반환합니다. mid를 right구간에 포함시켜 주면,\n두 구간의 경계가 맞닿게 되고, 탐색이 종료됩니다. $Q(x)$가 True인 최대 정수가 a[left]이고, False가 되는, 즉 $x$ 이상이 되는 최솟값이 a[right]가 됩니다. 따라서 이 문제의 정답은 a[right]가 됩니다!\n탐색할 구간이 절반씩 줄어들기 때문에, $\\frac{N}{2^k} \\leq 1$을 만족하는 최소한의 정수 $k$가 탐색한 횟수가 됩니다. 부등식을 정리하면, $\\lg N \\leq k$, 시간복잡도는 $\\mathcal{O}(\\lg N)$이 됩니다. 로그 시간복잡도는 일반적으로 상수 시간복잡도 다음으로 뛰어난 퍼포먼스를 보여줍니다. $N=10^9$ 스케일만 되어도, $\\lg10^9 = 29.8973\\cdots$이므로, 선형 알고리즘보다 $10^7$배 이상 빠릅니다. 정말 좋은 알고리즘입니다. 이해를 점검하기 위해 연습문제를 하나 풀어봅시다.\nBOJ 1920 - 수 찾기 문제 링크\n$Q(x)$를 어떻게 해야 잘 구성할 수 있을지 고민해봅시다. 찾으려는 값 $X$가 어디 사이에 있는지는 이분탐색을 통해 알 수 있지만, 어떻게 하면 배열 안에 존재하는지를 판단할 수 있을까요? Lower bound \u0026amp; Upper bound 배열에 같은 값이 여러 개 있으면 이분 탐색 결과가 어떻게 나올까요?\n위 예시는 질문 $Q(x)$를 \u0026ldquo;$x$ 미만인가?\u0026ldquo;로 정의했습니다. 따라서 a[right]가 $x$를 초과하는 최초의 정수가 되는데요, 만약 $R(x)$를 \u0026ldquo;$x$ 이하인가?\u0026ldquo;로 정의하면 a[left]와 a[right] 둘 중 무엇이 정답이 될까요? 이 때는 a[left]가 $x$ 이하인 최대의 정수이므로 a[left]가 정답이 됩니다. 전자를 Lower bound, 후자를 Upper bound라고 합니다.\n왼쪽의 하늘색이 바로 위의 문단에서 설명한 $Q(x)$를 이용한 Lower bound, 오른쪽의 주황색이 $R(x)$를 이용한 Upper bound입니다. 연습문제나 하나 풀어봅시다. BOJ 10816 - 숫자 카드 2 문제 링크\n숫자 카드들을 정렬한 후 (Upper bound) $-$ (Lower bound) $+ 1$을 하면 어떤 카드가 몇 장 있는지 알 수 있습니다! 하지만 애초에 존재하지 않을 수도 있으니 위 문제를 먼저 풀어본 후 잘 구현해봅시다.\n매개 변수 탐색 (Parametric Search) 초반에 언급했듯이, 제가 위에서 정의한 이분 탐색은 애초에 매개 변수 탐색으로 확장한 정의입니다. 원래의 이분 탐색은 특정한 값을 찾는 데 사용되지만, 매개 변수 탐색은 경계를 찾는 데 사용됩니다. 일반적으로, $1$부터 $N$까지의 범위 내에서 매개 변수 탐색을 수행할 때, $Q(x)$를 판단하는 데의 시간복잡도가 $\\mathcal{O}(M)$이라고 하면, 총 시간복잡도는 $\\mathcal{O}(\\lg N)\\cdot \\mathcal{O}(M) = \\mathcal{O}(M \\lg N)$이 됩니다.\n참고로 모든 최적화 문제를 결정 문제로 환원할 수는 없습니다. $Q(x)$가 단조적이지 않다면 (즉, True에서 False로 혹은 그 반대로 바뀌는 지점이 유일하지 않다면), 매개 변수 탐색을 활용할 수 없습니다. 보통 최댓값 또는 최솟값을 찾는 문제에 $Q(x)$를 단조성을 띄도록 잘 정의할 수 있고, 시간복잡도도 적당해 보인다면, 매개 변수 탐색을 적용해볼 수 있습니다!\nBOJ 2805 - 나무 자르기 문제 링크\n최대 높이가 $H \\le 10^9$이고, 나무가 $N \\le 10^6$그루 있습니다. $h$미터에 절단기를 설치했을 때 얻을 수 있는 목재의 양은 $\\mathcal{O}(N)$에 구할 수 있습니다. 총 시간복잡도는 $\\mathcal{O}(N \\lg H)$로 충분히 시간 안에 돌아갑니다! 자료형 선택에 유의하세요.\nBOJ 3079 - 입국심사 문제 링크\n$T$분 안에 심사를 마칠 수 있을까요? 이는 $\\mathcal{O}(N)$에 판단할 수 있습니다. Python 사용자가 아니라면, 아무도 모르게 어디선가 64비트 정수 범위도 초과할 수 있음에 주의합시다. (Hint: $T$분 안에 통과 가능한 사람이 몇 명인지 카운트할 때 혹시\u0026hellip;) 마지막으로 매개 변수 탐색을 활용한 웰노운 테크닉 하나를 소개하고자 합니다.\nBOJ 21556 - 우물 파기 문제 링크\n\u0026ldquo;중앙값으로 $x$가 가능한가?\u0026ldquo;를 이분 탐색으로 환원시키는 테크닉입니다. Codeforces 등지에서 은근 자주 만날 수 있는 유형입니다. $Q(x)$를 \u0026ldquo;$x$ 이하인 $A_i + A_j$ 쌍의 개수가 $\\lceil \\frac{S}{2} \\rceil$개 미만인가?\u0026ldquo;로 놓고 Lower bound를 구하면 될 것 같습니다. 하지만 $\\lceil \\frac{S}{2} \\rceil$가 최대 $10^8$ 스케일보다 더 커질 수 있어서, $Q(x)$의 답을 $\\mathcal{O}(\\lceil \\frac{S}{2} \\rceil)$에 구해서는 풀 수 없습니다. 더 생각해봅시다! 도전 문제 BOJ 32136 - 소신발언 문제 링크\n매개 변수 탐색 문제인데, 어떤 조건으로 최적화 문제를 결정 문제로 환원할 수 있을까요? 구현이 조금 까다로울 수 있습니다. BOJ 10227 - 삶의 질 문제 링크\n위에서 언급한 중앙값 테크닉의 응용입니다.\nBOJ 27947 - 가지 밭 게임 문제 링크\n매 턴마다 볼록 다각형의 넓이가 단조증가한다는 것을 관찰한다면 이분 탐색을 적용할 수 있습니다!\nBOJ 1557 - 제곱 ㄴㄴ 문제 링크\n포함-배제 원리를 사용해서 제곱ㄴㄴ수들의 개수를 빠르게 카운트해야 합니다. Lower bound와 Upper bound를 잘 생각하지 않으면 경계에 제곱ㄴㄴ수가 아닌 수가 걸려서 처리하기 곤란해질 수 있습니다. 마무리 이분 탐색은 PS에서 사용할 수 있는 가장 강력한 도구 중 하나입니다. 최솟값/최댓값을 구하는 최적화 문제를 이분 탐색으로 환원시킬 수 있다면, 반씩 구간을 줄여나간다는 성질로 인한 로그 시간복잡도 덕분에 상당히 유용하게 사용할 수 있습니다. 이분 탐색 많이 사랑해주세요.\n","permalink":"http://localhost:1313/posts/binary-search/","summary":"Intro 이분 탐색 알고리즘은 컴퓨터 공학을 전공하지 않더라도 누구나 교양 시간에 배워봤을 만한 알고리즘입니다. 이분 탐색의 개념 자체는 직관적이지만 응용이 상당히 어렵습니다. 오늘은 이분 탐색과 그 활용에 대해 다뤄보겠습니다. 이분 탐색이란? 이분 탐색이 정확히 무엇일까요? 이분 탐색의 예시로 보통 업-다운 게임을 많이 사용하는데요, 진행자는 $1$부터 $100$까지의 정수 중 하나를 고르고, 질문자는 이 정수를 맞혀야 합니다. 질문자는 매 질문마다 정수를 하나 골라 질문하고, 진행자는 질문자가 고른 정수와 진행자가 고른 정수의 대소관계만을 대답해줍니다.","title":"이분 탐색(Binary Search)과 활용"},{"content":"문제 링크\n(2024/9/13 기준) Gold V\n문제 읽기 문제가 살짝 난해합니다;\n$1$초부터 $T$초까지 매 초 $1$번 나무 또는 $2$번 나무에서 하나씩, 총 $T$개의 자두가 떨어집니다. $W$번 이하로 이동하며 떨어지는 자두를 받았을 때의 최댓값을 구해봅시다. 처음 시작은 $1$번 나무입니다.\n풀이 제한을 잘 살펴봅시다. $T \\leq 1 000$, $W \\leq 30$, 나무가 $2$그루 있으니, dp[현재 시간][현재 위치][현재까지 이동한 횟수]로 3차원 DP를 해볼 수 있을 것 같습니다.\n우선, DP 테이블에 초깃값들을 채워봅시다. $t$초에 자두가 떨어진 나무의 위치를 $P_t$라고 하면, $1$초에 $1$번 나무에서 시작하니, $DP_{1, 1, 0}=[P_i = 1]$이 되겠고 (편의상 $[c]$는 조건 $c$가 참이면 $1$, 거짓이면 $0$ 값을 가진다고 약속합시다), $1$초에 자두가 떨어지기 전 $2$번 나무로 움직였다면, $DP_{1, 2, 1}=[P_i = 2]$가 됩니다. (한 번 움직였으니, $DP_{1, 2, 0}$이 아닌, $DP_{1, 2, 1}$입니다!)\n이후 점화식은 다음과 같이 정의할 수 있습니다.\n$(k = 0)\\ DP_{i, j, 0} = DP_{i-1, j, 0} + [P_i = j]$ $(k \\neq 0)\\ DP_{i, j, k} = \\textrm{max}(DP_{i-1, j, k}, DP_{i-1, 3-j, k-1}) + [P_i = j]$ 여기서 $j$는 나무의 번호이므로, $1$ 또는 $2$만 들어갈 수 있습니다. 따라서, $3-j$는 반대쪽 나무를 뜻합니다. 점화식이 조금 복잡하지만, $i$초에 $j$번째 나무에 있고, $k$번 이동했을 때 받을 수 있는 자두의 최대 개수를 나타내므로, $i-1$초에서 $j$번 나무에 있는 경우와 나무를 바꾼 경우(즉, $3-j$번 나무에 있는 경우) 중에서 최댓값을 선택하여 갱신합니다. 시간복잡도는 $O(TW)$가 됩니다.\n코드 use std::{fmt::Write, io::{stdin, Read}, str::SplitWhitespace}; fn main() { let mut buf = String::new(); let mut out = String::new(); stdin().read_to_string(\u0026amp;mut buf).unwrap(); let mut scan = Scanner::new(buf.split_whitespace()); //let tc = scan.next(); //for i in 0..tc { solve(\u0026amp;mut scan, \u0026amp;mut out, 0); //} println!(\u0026#34;{out}\u0026#34;); } // overflow, edge case, and 1 based index? fn solve\u0026lt;\u0026#39;a\u0026gt;(scan: \u0026amp;mut Scanner\u0026lt;\u0026#39;a, SplitWhitespace\u0026lt;\u0026#39;a\u0026gt;\u0026gt;, out: \u0026amp;mut String, _tc: usize) { let n: usize = scan.next(); let w: usize = scan.next(); let mut a = vec![0; n + 1]; for i in 1..=n { a[i] = scan.next::\u0026lt;i32\u0026gt;(); } let mut dp = vec![vec![vec![-1; w + 1]; 3]; n + 1]; dp[1][1][0] = if a[1] == 1 { 1 } else { 0 }; dp[1][2][1] = if a[1] == 2 { 1 } else { 0 }; for i in 2..=n { for j in 1..=2 { dp[i][j][0] = dp[i - 1][j][0] + if a[i] == j as i32 { 1 } else { 0 }; for k in 1..=w { dp[i][j][k] = i32::max(dp[i - 1][3 - j][k - 1], dp[i - 1][j][k]) + if a[i] == j as i32 { 1 } else { 0 }; } } } let mut ans = dp[n][1][0]; for i in 1..=2 { for j in 0..=w { if ans \u0026lt; dp[n][i][j] { ans = dp[n][i][j]; } } } writeln!(out, \u0026#34;{ans}\u0026#34;).ok(); } struct Scanner\u0026lt;\u0026#39;a, I: Iterator\u0026lt;Item = \u0026amp;\u0026#39;a str\u0026gt;\u0026gt; { iter: I, } impl\u0026lt;\u0026#39;a, I: Iterator\u0026lt;Item = \u0026amp;\u0026#39;a str\u0026gt;\u0026gt; Scanner\u0026lt;\u0026#39;a, I\u0026gt; { fn new(from: I) -\u0026gt; Self { Self { iter: from } } fn next\u0026lt;T: std::str::FromStr\u0026gt;(\u0026amp;mut self) -\u0026gt; T { self.iter.next().unwrap().parse().ok().unwrap() } } 평범한 바텀업 3차원 DP 코드입니다. 마지막에 몇 번을 움직여야 최대가 나올 지 알 수 없으니, $DP_{T, 1, 1}$부터 $DP_{T, 2, W}$까지 돌면서 최댓값을 갱신해주면 됩니다.\n후기 DP 어렵습니다\u0026hellip; 엄청 많이 고민하고 풀었던 문제입니다.\n","permalink":"http://localhost:1313/posts/boj-2240/","summary":"문제 링크\n(2024/9/13 기준) Gold V\n문제 읽기 문제가 살짝 난해합니다;\n$1$초부터 $T$초까지 매 초 $1$번 나무 또는 $2$번 나무에서 하나씩, 총 $T$개의 자두가 떨어집니다. $W$번 이하로 이동하며 떨어지는 자두를 받았을 때의 최댓값을 구해봅시다. 처음 시작은 $1$번 나무입니다.\n풀이 제한을 잘 살펴봅시다. $T \\leq 1 000$, $W \\leq 30$, 나무가 $2$그루 있으니, dp[현재 시간][현재 위치][현재까지 이동한 횟수]로 3차원 DP를 해볼 수 있을 것 같습니다.\n우선, DP 테이블에 초깃값들을 채워봅시다. $t$초에 자두가 떨어진 나무의 위치를 $P_t$라고 하면, $1$초에 $1$번 나무에서 시작하니, $DP_{1, 1, 0}=[P_i = 1]$이 되겠고 (편의상 $[c]$는 조건 $c$가 참이면 $1$, 거짓이면 $0$ 값을 가진다고 약속합시다), $1$초에 자두가 떨어지기 전 $2$번 나무로 움직였다면, $DP_{1, 2, 1}=[P_i = 2]$가 됩니다.","title":"BOJ 2240 - 자두나무"},{"content":"문제 링크\n(2024/9/12 기준) Silver I\n문제 읽기 $N$명의 사람들이 일렬로 서 있습니다. 왼쪽에서 $i$ (단, $1 \\leq i \u0026lt; N$)번째 사람까지는 홍팀, 나머지는 청팀으로, 총 $N-1$가지 방법으로 팀을 나눌 수 있습니다. 이때, 각 팀에서 힘이 가장 센 사람이 힘을 겨루어, 두 사람 중 힘이 더 센 사람이 포함된 팀이 승리하게 됩니다. (무승부일 때는 어느 팀도 승리하지 않습니다.) 둘 중 어느 팀이 승리할 확률이 더 높을까요?\n풀이 일단, 전체 경우의 수는 $N-1$로 고정되어 있습니다. 확률을 굳이 구하지 않고, 어느 팀이 더 많이 이겼는 지만 확인하면 됩니다.\n관찰을 조금 해봅시다. 홍팀은 $1$번째 사람부터, $i$번째 사람까지 포함합니다. 청팀은 $i+1$번째 사람부터 $N$번째 사람을 포함합니다. $i$를 조금씩 옮겨가다보면, $1$번째 사람은 반드시 홍팀에, $N$번째 사람은 반드시 청팀에 포함된다는 사실을 알 수 있습니다. 그렇다면, $1$번째 사람부터 $i$번째 사람까지 홍팀에 포함했을 때, 홍팀에서 가장 힘이 센 사람의 힘을 $R_i$, 청팀에서 가장 힘이 센 사람의 힘을 $B_i$라고 합시다. $P_k$을 $k$번째 사람의 힘이라고 하면, $R_i$는 $R_1 = P_1$, $R_i = \\textrm{max}(R_{i-1}, P_{i})$가 되고, 비슷한 방법으로 $B_{n-1} = P_n$, $B_i = \\textrm{max}(B_{i+1}, P_{i+1})$가 됩니다. 이는 누적합을 통해 각각 $\\mathcal{O}(N)$에 구할 수 있습니다.\n이제, $i$에 $1$부터 $N-1$까지 넣어보면서 청팀 또는 홍팀이 이기는 경우를 세어주면 됩니다. 역시 시간복잡도는 $\\mathcal{O}(N)$입니다. 청팀과 홍팀 모두 이기는 경우의 수가 같을 땐, X를 출력해야 함에 유의합시다.\n코드 use std::{fmt::Write, io::{stdin, Read}, str::SplitWhitespace}; fn main() { let mut buf = String::new(); let mut out = String::new(); stdin().read_to_string(\u0026amp;mut buf).unwrap(); let mut scan = Scanner::new(buf.split_whitespace()); //let tc = scan.next(); //for i in 0..tc { solve(\u0026amp;mut scan, \u0026amp;mut out, 0); //} println!(\u0026#34;{out}\u0026#34;); } // overflow, edge case, and 1 based index? fn solve\u0026lt;\u0026#39;a\u0026gt;(scan: \u0026amp;mut Scanner\u0026lt;\u0026#39;a, SplitWhitespace\u0026lt;\u0026#39;a\u0026gt;\u0026gt;, out: \u0026amp;mut String, _tc: usize) { let n: usize = scan.next(); let mut a = vec![0; n]; for i in 0..n { a[i] = scan.next::\u0026lt;i32\u0026gt;(); } let mut r = vec![0; n - 1]; r[0] = a[0]; for i in 1..(n - 1) { r[i] = if r[i - 1] \u0026lt; a[i] { a[i] } else { r[i - 1] }; } let mut b = vec![0; n - 1]; b[n - 2] = a[n - 1]; for i in (0..(n - 2)).rev() { b[i] = if b[i + 1] \u0026lt; a[i + 1] { a[i + 1] } else { b[i + 1] }; } let mut rw = 0; let mut bw = 0; for i in 0..(n - 1) { if r[i] \u0026gt; b[i] { rw += 1; } if r[i] \u0026lt; b[i] { bw += 1; } } writeln!(out, \u0026#34;{}\u0026#34;, if rw \u0026gt; bw { \u0026#39;R\u0026#39; } else if rw \u0026lt; bw { \u0026#39;B\u0026#39; } else { \u0026#39;X\u0026#39; }).ok(); } struct Scanner\u0026lt;\u0026#39;a, I: Iterator\u0026lt;Item = \u0026amp;\u0026#39;a str\u0026gt;\u0026gt; { iter: I, } impl\u0026lt;\u0026#39;a, I: Iterator\u0026lt;Item = \u0026amp;\u0026#39;a str\u0026gt;\u0026gt; Scanner\u0026lt;\u0026#39;a, I\u0026gt; { fn new(from: I) -\u0026gt; Self { Self { iter: from } } fn next\u0026lt;T: std::str::FromStr\u0026gt;(\u0026amp;mut self) -\u0026gt; T { self.iter.next().unwrap().parse().ok().unwrap() } } 핵심은 $R_i$와 $B_i$를 구하는 과정인데요, 구간의 시작과 끝인 $1$, $i$, $i+1$, $N$ 중 고정된 값은 $1$과 $N$이므로, $R_i$는 정방향으로, $B_i$는 역방향으로 누적하며 최댓값을 채워주었습니다.\n후기 조금은 아이디어성의 문제라고 생각했지만, 누적합을 응용해 구간의 최댓값/최솟값을 관리하는 방법이 기초 문제에 있다고 하네요\u0026hellip;\n+ 놀랍게도 브루트포스를 살짝만 최적화해도 풀린다고 합니다. 충격!\n","permalink":"http://localhost:1313/posts/boj-17251/","summary":"문제 링크\n(2024/9/12 기준) Silver I\n문제 읽기 $N$명의 사람들이 일렬로 서 있습니다. 왼쪽에서 $i$ (단, $1 \\leq i \u0026lt; N$)번째 사람까지는 홍팀, 나머지는 청팀으로, 총 $N-1$가지 방법으로 팀을 나눌 수 있습니다. 이때, 각 팀에서 힘이 가장 센 사람이 힘을 겨루어, 두 사람 중 힘이 더 센 사람이 포함된 팀이 승리하게 됩니다. (무승부일 때는 어느 팀도 승리하지 않습니다.) 둘 중 어느 팀이 승리할 확률이 더 높을까요?\n풀이 일단, 전체 경우의 수는 $N-1$로 고정되어 있습니다.","title":"BOJ 17251 - 힘 겨루기"},{"content":"문제 링크\n(2024/9/10 기준) Gold III\n문제 읽기 하노이 탑 변형 문제입니다. 대신 기둥 D가 추가되었고, 기둥 D에 한 번 옮기면 다시 뺄 수 없습니다. 이외에는 기존 하노이 탑과 규칙이 동일합니다. $N$개의 원판을 기둥 D에 옮기는 최소 이동 횟수와, 그러한 이동 방법을 하나 찾아봅시다.\n예시 편의를 위해 초기 상태에서의 위로부터 $N$번째 원판을 원판 $N$이라고 하겠습니다. $N=2$일 때,\nA에 있는 원판 $1$을 B로 옮긴다. A에 있는 원판 $2$를 D로 옮긴다. B에 있는 원판 $1$을 D로 옮긴다. 이렇게 최소 이동 횟수 $3$회로 모든 원판을 기둥 D로 옮길 수 있습니다.\n풀이 Base Case $N=1$인 경우, 바로 기둥 D로 옮기면 최소가 됩니다.\n$N=2$인 경우, 위 예시대로 기둥 D로 옮길 수 있고, 사용하는 기둥의 순서가 바뀌어도 이는 이동 횟수는 바뀌지 않으므로, 최소가 됩니다.\nStep $n \\geq 3$인 경우, $1$번 원판부터 $N-2$번 원판을 기둥 D를 임의의 기둥으로 옮겨서 $N-2$인 경우를 만들 수 있습니다. (편의를 위해 기둥 C에 옮겼다고 합시다.) 그러면, 기둥 A에는 원판 $N$과 $N-1$이 남게되고, 이 두 원판을 기둥 D로 옮긴 후, 기둥 C에서 기둥 D로 $N-2$개의 원판을 옮기면 됩니다.\n만약, 원판 $N$ 하나만 남기고 $1$부터 $N-1$을 옮긴다고 해봅시다. 그렇다면 $N-1$개의 원반을 가지고 반복하고, 더 많은 횟수로 옮겨야 합니다.\n또한, 원판을 $3$개 이상 남기려고 하면, 하노이의 탑 규칙을 만족하면서 남은 원판들을 기둥 D로 옮길 수 없습니다. 따라서 $2$개의 원판을 남기고, (단, $N=3$일 때에는 하나밖에 남을 수 없습니다.) 나머지 $N-2$개의 원판을 기존 하노이 탑처럼 옮겨주면 최적해가 됩니다 $_\\blacksquare$\n코드 use std::{fmt::Write, io::{stdin, Read}, str::SplitWhitespace}; fn main() { let mut buf = String::new(); let mut out = String::new(); stdin().read_to_string(\u0026amp;mut buf).unwrap(); let mut scan = Scanner::new(buf.split_whitespace()); //let tc = scan.next(); //for _ in 0..tc { solve(\u0026amp;mut scan, \u0026amp;mut out); //} println!(\u0026#34;{out}\u0026#34;); } // overflow, edge case, and 1 based index? fn solve\u0026lt;\u0026#39;a\u0026gt;(scan: \u0026amp;mut Scanner\u0026lt;\u0026#39;a, SplitWhitespace\u0026lt;\u0026#39;a\u0026gt;\u0026gt;, out: \u0026amp;mut String) { let n: usize = scan.next(); let mut c = 0; res(n, \u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;, out, \u0026amp;mut c); println!(\u0026#34;{c}\u0026#34;); } fn res(n: usize, a: char, b: char, c: char, out: \u0026amp;mut String, cnt: \u0026amp;mut usize) { if n == 1 { writeln!(out, \u0026#34;{a} D\u0026#34;).ok(); *cnt += 1; return; } if n == 2 { writeln!(out, \u0026#34;{a} {b}\u0026#34;).ok(); writeln!(out, \u0026#34;{a} D\u0026#34;).ok(); writeln!(out, \u0026#34;{b} D\u0026#34;).ok(); *cnt += 3; return; } hanoi(n - 2, a, c, b, out); *cnt += 2_usize.pow(n as u32 - 2) - 1; writeln!(out, \u0026#34;{a} {b}\u0026#34;).ok(); writeln!(out, \u0026#34;{a} D\u0026#34;).ok(); writeln!(out, \u0026#34;{b} D\u0026#34;).ok(); *cnt += 3; res(n - 2, c, b, a, out, cnt); } fn hanoi(n: usize, a: char, b: char, c: char, out: \u0026amp;mut String) { if n == 1 { writeln!(out, \u0026#34;{a} {b}\u0026#34;).ok(); return; } hanoi(n - 1, a, c, b, out); writeln!(out, \u0026#34;{a} {b}\u0026#34;).ok(); hanoi(n - 1, c, b, a, out); } struct Scanner\u0026lt;\u0026#39;a, I: Iterator\u0026lt;Item = \u0026amp;\u0026#39;a str\u0026gt;\u0026gt; { iter: I, } impl\u0026lt;\u0026#39;a, I: Iterator\u0026lt;Item = \u0026amp;\u0026#39;a str\u0026gt;\u0026gt; Scanner\u0026lt;\u0026#39;a, I\u0026gt; { fn new(from: I) -\u0026gt; Self { Self { iter: from } } fn next\u0026lt;T: std::str::FromStr\u0026gt;(\u0026amp;mut self) -\u0026gt; T { self.iter.next().unwrap().parse().ok().unwrap() } } 변형 하노이를 해결하는 과정에 일반 하노이의 이동 순서가 필요하므로, 재귀함수를 두 개 만들었습니다.\n후기 도널드 커누스의 \u0026lt;구체 수학(Concrete Mathematics)\u0026gt;을 읽어본 적이 있었는데, 여기서 하노이 탑을 심도있게 다뤘습니다. 읽어보길 잘 했네요.\n","permalink":"http://localhost:1313/posts/boj-11729/","summary":"문제 링크\n(2024/9/10 기준) Gold III\n문제 읽기 하노이 탑 변형 문제입니다. 대신 기둥 D가 추가되었고, 기둥 D에 한 번 옮기면 다시 뺄 수 없습니다. 이외에는 기존 하노이 탑과 규칙이 동일합니다. $N$개의 원판을 기둥 D에 옮기는 최소 이동 횟수와, 그러한 이동 방법을 하나 찾아봅시다.\n예시 편의를 위해 초기 상태에서의 위로부터 $N$번째 원판을 원판 $N$이라고 하겠습니다. $N=2$일 때,\nA에 있는 원판 $1$을 B로 옮긴다. A에 있는 원판 $2$를 D로 옮긴다. B에 있는 원판 $1$을 D로 옮긴다.","title":"BOJ 11729 - 3+1 하노이 탑"},{"content":"문제 링크\n(2024/9/9 기준) Gold III\n문제 읽기 꽃이 $N$종류 주어집니다. 각각의 꽃은 피는 날과 지는 날이 각각 $MM\\ DD$꼴로 주어지고, 최소한의 종류의 꽃으로 $3$월 $1$일부터 $11$월 $31$일까지 매일 적어도 한 종류의 꽃이 피어있도록 배치해봅시다. 단, $d$일에 꽃이 지는 경우, $d$일에는 꽃이 피어있지 않았음에 유의합시다.\n예시 4 1 1 5 31 1 1 6 30 5 15 8 31 6 10 12 10 예제 1입니다. $4$종류의 꽃이 주어졌고, 이 중 $1$월 $1$일부터 $6$월 $30$일까지 피는 꽃과, $6$월 $10$일부터 $12$월 $10$일에 지는 꽃 $2$개를 선택하여 조건을 만족시킬 수 있습니다.\n풀이 먼저, $MM\\ DD$꼴로 주어지는 입력을 편하게 다루기 위해, $MM\\ DD$가 그 해의 몇 번째 날인지로 바꿔줍시다. 예를 들어, $1\\ 1$은 $1$이 되고, $5\\ 31$은 $151$이 됩니다. 이는 각 월의 일 수를 더하여 얻을 수 있습니다. 편의를 위해 $i$번째 꽃의 피는 날을 $s_i$, 지는 날을 $e_i$라 합시다.\n임의의 날짜 $d$에 대해서, $d$일에 꽃이 피어있기 위해서는 $s_i \\leq d \u0026lt; e_j$ (단, $1 \\leq i, j \\leq n$)를 만족해야 합니다.\n가장 간단하게, $n=1$인 상황을 가정해봅시다. $s_1 \\leq d \u0026lt; e_1$을 만족한다면 $1$개의 꽃을 선택하여 조건을 만족시킬 수 있습니다.\n$n \u0026gt; 1$일 경우, $s_i\u0026gt;e_j$ (단, $i \\neq j$)를 만족한다면, 두 구간을 합칠 수 있습니다. 예를 들어, 구간 $[2, 5)$와 $[4, 8)$을 합쳐 구간 $[2, 8)$을 만들 수 있고, 이 구간을 합치는 연산에 대해서는 교환법칙과 결합법칙이 성립합니다.\n모든 구간을 합쳐보고, 문제 조건에서 요구하는 구간인 $[60, 334)$를 덮을 수 있는지 확인하면, 모든 꽃을 배치해도 문제 조건을 만족할 수 없는 경우를 걸러낼 수 있습니다.\n이어서, 최소한의 종류의 꽃으로 구간을 덮을 방법을 찾아봅시다.\n두 구간 $[s_1, e_1)$, $[s_2, e_2)$중 짧거나 같은 구간이 합쳤을 때 완전히 덮히는 경우를 생각해봅시다. 즉, $s_1 \\leq s_2$이고, $e_1 \\geq e_2$라면, 두 구간을 합쳐도 $[s_1, e_1)$입니다. 교환법칙과 결합법칙이 성립하므로, 적절히 구간을 합쳐서 최소 개수로 덮는 구간과 그 외의 구간들로 나눌 수 있고, 최소 개수로 덮는 구간에는 결국 구간끼리 완전히 포개지는 경우가 없어야 함을 통해 알 수 있습니다.\n우선, 시간순으로 펼쳐보기 위해 $(s_i, e_i)$를 정렬합시다. $d$는 첫 날인 $60$이 되고, $s_i \\leq d$이고 $d \u0026lt; e_i$인 구간만을 선택할 수 있습니다. 만약, 임의의 $i$, $j$ (단, $1 \\leq i \u0026lt; j \\leq n$)에 대하여 $e_i \\leq e_j$이므로, 구간 $[s_i, e_i)$는 전체 구간 $[60, e_j)$ 안에 포함돼서 겹칩니다. 따라서, $s_i \\leq d$를 만족하면서 $e_i$가 최대가 되는 구간을 그리디하게 고르는 것이 최적이 됩니다. 같은 방식으로, $d = e_i$로 바꾼 후 귀납적으로 문제를 해결할 수 있습니다.\n소스코드 (Rust) use std::{fmt::Write, io::{stdin, Read}, str::SplitWhitespace}; fn main() { let mut buf = String::new(); let mut out = String::new(); stdin().read_to_string(\u0026amp;mut buf).unwrap(); let mut scan = Scanner::new(buf.split_whitespace()); //let tc = scan.next(); //for _ in 0..tc { solve(\u0026amp;mut scan, \u0026amp;mut out); //} println!(\u0026#34;{out}\u0026#34;); } // overflow, edge case, and 1 based index? fn solve\u0026lt;\u0026#39;a\u0026gt;(scan: \u0026amp;mut Scanner\u0026lt;\u0026#39;a, SplitWhitespace\u0026lt;\u0026#39;a\u0026gt;\u0026gt;, out: \u0026amp;mut String) { let n: usize = scan.next(); let mut a = Vec::with_capacity(n); for _ in 0..n { let sm: i32 = scan.next(); let sd: i32 = scan.next(); let em: i32 = scan.next(); let ed: i32 = scan.next(); a.push((get_day(sm, sd), get_day(em, ed))); } let mut s = get_day(3, 1); let mut e = 0; a.sort(); let mut flag = true; let mut c = 1; for i in 0..a.len() { if a[i].0 \u0026lt;= s { if e \u0026lt; a[i].1 { e = a[i].1; } } else { s = e; e = 0; c += 1; if s \u0026lt; a[i].0 { flag = false; break; } if e \u0026lt; a[i].1 { e = a[i].1; } } if e \u0026gt; get_day(11, 30) { break; } } if e \u0026lt;= get_day(11, 30) { flag = false; } writeln!(out, \u0026#34;{}\u0026#34;, if flag { c } else { 0 }).ok(); } fn get_day(m: i32, d: i32) -\u0026gt; i32 { let mut ret = 31 * (m - 1); for i in 1..m { if i == 2 { ret -= 3; } if i == 4 || i == 6 || i == 9 || i == 11 { ret -= 1; } } ret + d } struct Scanner\u0026lt;\u0026#39;a, I: Iterator\u0026lt;Item = \u0026amp;\u0026#39;a str\u0026gt;\u0026gt; { iter: I, } impl\u0026lt;\u0026#39;a, I: Iterator\u0026lt;Item = \u0026amp;\u0026#39;a str\u0026gt;\u0026gt; Scanner\u0026lt;\u0026#39;a, I\u0026gt; { fn new(from: I) -\u0026gt; Self { Self { iter: from } } fn next\u0026lt;T: std::str::FromStr\u0026gt;(\u0026amp;mut self) -\u0026gt; T { self.iter.next().unwrap().parse().ok().unwrap() } } get_day()함수를 통하여 $MM\\ DD$꼴의 입력을 $d$ 꼴로 바꿔주었고, 각 구간들을 정렬한 후, $s_i \u0026lt; d \u0026lt; e_i$를 만족하며 $e_i$가 최대가 되는 $i$를 찾은 후, $d$를 $e_i$로 업데이트 하며 합친 구간의 개수들을 더해주었습니다.\n$N$개의 꽃을 정렬하는 데에 $\\mathcal{O}(N\\lg N)$, 순회하는 데에 $\\mathcal{O}(N)$이고, 총 시간복잡도는 $\\mathcal{O}(N\\lg N)$입니다.\n후기 전형적인 그리디 유형이라 어느정도 직관이 있으신 분들은 쉽게 풀었을 수도 있는 문제입니다. 부등호를 포함하여 예외처리가 조금 어려웠지만 재밌었습니다.\n","permalink":"http://localhost:1313/posts/boj-2457/","summary":"문제 링크\n(2024/9/9 기준) Gold III\n문제 읽기 꽃이 $N$종류 주어집니다. 각각의 꽃은 피는 날과 지는 날이 각각 $MM\\ DD$꼴로 주어지고, 최소한의 종류의 꽃으로 $3$월 $1$일부터 $11$월 $31$일까지 매일 적어도 한 종류의 꽃이 피어있도록 배치해봅시다. 단, $d$일에 꽃이 지는 경우, $d$일에는 꽃이 피어있지 않았음에 유의합시다.\n예시 4 1 1 5 31 1 1 6 30 5 15 8 31 6 10 12 10 예제 1입니다. $4$종류의 꽃이 주어졌고, 이 중 $1$월 $1$일부터 $6$월 $30$일까지 피는 꽃과, $6$월 $10$일부터 $12$월 $10$일에 지는 꽃 $2$개를 선택하여 조건을 만족시킬 수 있습니다.","title":"BOJ 2457 - 공주님의 정원"},{"content":"문제 링크\n(2024/9/10 기준) Gold V\n문제 읽기 $1$부터 $N$까지의 자연수를 색칠해야 합니다. 단, 서로소인 두 자연수는 서로 다른 색으로 칠해야 하고, 최소한의 색을 사용해야 합니다.\n예시 $n=5$일 때, $1\\ 2\\ 3\\ 4\\ 5$를 $\\color{salmon}1\\ \\color{sandybrown}2\\ \\color{seagreen}3\\ \\color{sandybrown}4\\ \\color{skyblue}5$로 $4$가지 색을 이용하여 색칠할 수 있습니다. 따라서, 정답은 $1\\ 2\\ 3\\ 2\\ 4$입니다. (색의 순서는 상관이 없습니다. 최소 개수를 만족하기만 한다면 정답으로 인정됩니다. 또한, $6$을 $2$와 같은 색으로 칠하든 $3$과 같은 색으로 칠하든 모두 정답으로 인정됩니다.)\n풀이 일단, $1$은 모든 자연수와 서로소입니다. 따라서, $1$은 $1$을 제외한 자연수와 다른 색으로 칠해야 합니다. 또한, 서로 다른 두 소수 $p_1$, $p_2$는 서로소이므로, 다른 색으로 칠해야 합니다. 만약, 합성수 $C$가 자신의 소인수에 칠해진 색과 다른 색으로 칠해진다면, 서로소인 두 자연수를 같은 색으로 칠하게 되거나, 그렇지 않으면 불필요한 색이 하나가 늘어나므로, 최소한의 색으로 색칠할 수 없습니다. 따라서, $N$이하의 소수 $p$ 각각에 대하여, $p$와 $p$의 모든 배수들끼리 같은 색으로 칠한다면 최소한의 개수의 색으로 칠할 수 있게 됩니다.\n이때, 소수와 그 배수들을 다루는 방법이 하나 있습니다. 바로 에라토스테네스의 체 입니다. 에라토스테네스의 체의 일반적인 구현은 bool배열을 이용하는 것인데, bool 대신 int배열을 사용하여 $k$번째 소수와 그 배수들을 모두 $k + 1$로 업데이트하면 됩니다. ($1$도 색칠해야 하므로, $2$가 첫 번째 소수이지만, $2$번째 색이 됩니다.)\n그렇다면, 색의 개수의 최솟값은 어떻게 알 수 있을까요? $1$부터 $N$까지 임의의 소수 $p$와 그 배수들이 모두 한 가지 동일한 색으로 칠해지므로, $N$이하의 소수의 개수만 알면 됩니다. 즉, $(N$ 이하의 소수의 개수$) + 1$개 의 색으로 칠할 수 있고, 이것이 최소라는 결론이 자연스럽게 도출됩니다.\n해당 풀이의 시간복잡도는 에라토스테네스의 체와 동일한 $\\mathcal{O}(N\\lg(\\lg N))$입니다. (여기서 $\\lg$는 밑이 $2$인 이진로그입니다.) 따라서, $N \\leq 500\\ 000$이므로, 충분히 제한 시간 $1$초 내에 동작합니다.\n후기 매우 직관적이고 쉬운 문제지만, 에라토스테네스의 체의 작동 방식에 대한 정확한 이해 없이는 풀기 어려운 문제 같습니다.\n","permalink":"http://localhost:1313/posts/boj-23048/","summary":"문제 링크\n(2024/9/10 기준) Gold V\n문제 읽기 $1$부터 $N$까지의 자연수를 색칠해야 합니다. 단, 서로소인 두 자연수는 서로 다른 색으로 칠해야 하고, 최소한의 색을 사용해야 합니다.\n예시 $n=5$일 때, $1\\ 2\\ 3\\ 4\\ 5$를 $\\color{salmon}1\\ \\color{sandybrown}2\\ \\color{seagreen}3\\ \\color{sandybrown}4\\ \\color{skyblue}5$로 $4$가지 색을 이용하여 색칠할 수 있습니다. 따라서, 정답은 $1\\ 2\\ 3\\ 2\\ 4$입니다. (색의 순서는 상관이 없습니다. 최소 개수를 만족하기만 한다면 정답으로 인정됩니다. 또한, $6$을 $2$와 같은 색으로 칠하든 $3$과 같은 색으로 칠하든 모두 정답으로 인정됩니다.","title":"BOJ 23048 - 자연수 색칠하기"},{"content":"문제 링크\n(2024/7/17 기준) Diamond V\n문제 읽기 연속된 정수 구간 $Q$와 연속된 양의 정수 구간 $P$가 있습니다. 연속된 구간 $PQ$에 대하여, 구간 $Q$의 길이 $q$가 주어졌을 때, 구간 $P$의 합과 구간 $Q$의 합이 같을 때의 가능한 $p$가 몇 개나 있을지 세어봅시다.\n예시 $\\underbrace{9+10+11+12} _{P} = \\underbrace{13+14+15} _{Q}$는 $p=4$, $q=3$인 예시입니다.\n$\\underbrace{4+5+6+7+8} _{P} = \\underbrace{9+10+11} _{Q}$은 $p=5$, $q=3$인 예시입니다.\n풀이 먼저, $p\u0026gt;q$임을 캐치합시다. 구간 $P$는 항상 구간 $Q$의 왼쪽에 붙어있기 때문에, $p\\leq q$라면, 항상 구간 $P$의 합은 구간 $Q$의 합보다 작습니다. 따라서, $p\u0026gt;q$여야만 두 구간의 합이 같을 수 있습니다.\n양의 정수 $n$이 구간 $P$의 오른쪽 끝이라고 합시다.\n구간 $Q$의 합은 당연히 양의 정수이므로, 구간 $P$의 합이 양의 정수가 되기 위해서는, $n$이 양의 정수여야 함이 자명합니다.\n구간 $P$의 합은, $\\underbrace{n+(n-1)+\\cdots+(n-p+1)} _{p\\text{ terms}}$이므로, $pn-\\frac{p(p-1)}{2}$로 정리할 수 있습니다.\n같은 방법으로, 구간 $Q$의 합은, $\\underbrace{(n+1)+(n+2)+\\cdots+(n+q)} _{q\\text{ terms}}$이므로, $qn+\\frac{q(q+1)}{2}$로 정리할 수 있습니다.\n두 합이 같아야 하므로, $pn-\\frac{p(p-1)}{2}=qn+\\frac{q(q+1)}{2}$로 놓고, 식을 조금 변형합시다.\n$(p-q)n=\\frac{p^2 + q^2}{2} - \\frac{p-q}{2}$, $p\u0026gt;q$이므로, 양변을 $(p-q)$로 나누면, $n=\\frac{p^2 + q^2}{2(p-q)}-\\frac 1 2$입니다.\n$p^2 + q^2 = p^2 - q^2 + 2q^2 = (p+q)(p-q) + 2q^2$를 이용해서 다시 정리해주면,\n$n=\\frac{p+q-1}{2} + \\frac{q^2}{p-q}$가 됩니다.\n이를 만족하는 모든 $n$, $p$의 쌍을 찾아봅시다!\n$n$이 양의 정수이므로, $p$, $q$의 홀짝성(parity)에 따라 케이스를 나눠야 합니다.\n1-1. $p$는 홀수, $q$는 짝수 $p+q$와 $p-q$는 모두 홀수입니다.\n$\\frac{p+q-1}{2}$은 양의 정수이고, $\\frac{q^2}{p-q}$도 양의 정수여야 합니다.\n따라서, $(p-q) \\vert q^2$입니다.\n1-2. $p$는 홀수, $q$는 홀수 $p-q$와 $p+q$가 모두 짝수입니다.\n$\\frac{p+q-1}{2}$이 정수가 아니므로, $\\frac{q^2}{p-q}$가 $\\frac{2m-1}{2}$꼴이어야 합니다. (단, $m$은 양의 정수)\n따라서, $\\frac{q^2}{p-q} = \\frac{2q^2}{2(p-q)} = \\frac{1}{2} \\times \\frac{2q^2}{p-q}$로 변형할 수 있고, $(p-q) \\vert 2q^2$입니다.\n2-1. $p$는 짝수, $q$는 홀수 $p-q$와 $p+q$가 모두 홀수입니다.\n$\\frac{q^2}{p-q}$이 정수여야 하므로, $(p-q) \\vert q^2$.\n약간의 관찰을 더 해봅시다.\n$p-q$가 홀수이므로, $q^2$의 $2$ 소인수들은 있으나 마나입니다. ($q$가 짝수이므로 반드시 $2$를 적어도 하나 소인수로 갖는데, $p-q$는 홀수이므로 $2$를 소인수로 가질 수 없습니다.)\n$q=2^k \\times r$이라고 하면, $(p-q) \\vert r^2$입니다.\n2-2. $p$는 짝수, $q$는 짝수 $p-q$와 $p+q$가 모두 짝수입니다.\n$\\frac{p+q-1}{2}$이 정수가 아니므로, $\\frac{q^2}{p-q}$가 $\\frac{2m-1}{2}$꼴이어야 합니다. (단, $m$은 양의 정수)\n2-1. 에서 사용한 아이디어를 가져와서, $q^2 = 2^{2k} \\times r^2$이고, $p-q$는 $2^{2k+1} \\times s$꼴이어야 합니다. (단, $s$는 홀수)\n다시 정리해보면, $\\frac{q^2}{p-q} = \\frac 1 2 \\times \\frac{r^2}{s}$이므로, $s \\vert r^2$입니다.\n결론 위의 4가지 케이스를 정리해 봅시다.\n1-1. 1-2. 케이스를 정리해 보면, 1-1.에서 가능한 $p$의 개수는 $q$와 $q^2$가 모두 홀수이므로, $q^2$의 약수의 개수와 같다는 것을 알 수 있고, 1-2.에서 가능한 모든 $p-q$들은 1-1.에서 가능한 모든 $p-q$들에 $2$를 곱한 값이고, 이들은 서로 홀짝성이 다르기 때문에, 전부 서로 다른 정수임을 알 수 있습니다.\n따라서, $q$가 홀수일 때 가능한 $p$의 개수는 $q^2$의 약수의 개수의 $2$배가 됩니다.\n2-1. 2-2. 케이스도 정리해 보면, 2-1.에서의 $p-q$가 가질 수 있는 값이 $r^2$의 약수뿐이고, 2-2.에서 $s$가 가질 수 있는 값도 $r^2$의 약수뿐이니, 가능한 $p-q$와 $s$의 개수는 각각 $r^2$의 약수의 개수로 같습니다. 다만, 2-2.의 $p-q$는$s \\times 2^{2k+1}$이므로 2-1.에서의 $p-q$와 각각 다르고, 홀짝성도 다르므로, 전부 서로 다른 정수임을 알 수 있습니다.\n따라서, $q$가 짝수일 때 가능한 $p$의 개수는 $q=2^k \\times r$인 홀수 $r$에 대하여, $r^2$의 약수의 개수의 $2$배가 됩니다.\n1-1.~2-2.를 모두 일반화 시킬 수도 있습니다. $q$가 $2$로 나누어떨어지지 않을 때까지 나눈 수를 $q^{\\prime}$이라고 하면, $\\lbrace q^{\\prime} \\rbrace ^ 2$의 약수의 개수의 $2$배가 문제의 정답이 됩니다.\n구현은 에라토스테네스의 체를 쓰든 폴라드-로를 쓰든 넉넉하게 통과됩니다.\n참고로 저는 안전하게 폴라드-로를 사용했습니다.\n약수의 개수를 구하는 방법은\u0026hellip; 중학교 수학 내용이니, 다들 아시길 바라며 넘어가겠습니다.\n후기 제가 처음으로 자력솔에 성공한 다이아몬드 문제입니다. 난이도 외에 어떠한 정보도 없이 스스로 해결한 문제라 더욱 뿌듯하네요.\n3일정도 시간이 걸렸고 (사실 요즘 ps를 잘 안 하긴 합니다.), 공책도 6장 넘게 사용했습니다.\n블로그에 올린 이유는 문제가 되게 재밌었기도 하고, 백준 메모에 $\\TeX$ 문법으로 남겨둔 수식도 많았고, 이미 다른 분이 블로그에 먼저 올리셨는데, 저와 접근이 조금 달라 보여서 올려봤습니다.\n읽어주셔서 감사합니다.\n","permalink":"http://localhost:1313/posts/boj-5647/","summary":"문제 링크\n(2024/7/17 기준) Diamond V\n문제 읽기 연속된 정수 구간 $Q$와 연속된 양의 정수 구간 $P$가 있습니다. 연속된 구간 $PQ$에 대하여, 구간 $Q$의 길이 $q$가 주어졌을 때, 구간 $P$의 합과 구간 $Q$의 합이 같을 때의 가능한 $p$가 몇 개나 있을지 세어봅시다.\n예시 $\\underbrace{9+10+11+12} _{P} = \\underbrace{13+14+15} _{Q}$는 $p=4$, $q=3$인 예시입니다.\n$\\underbrace{4+5+6+7+8} _{P} = \\underbrace{9+10+11} _{Q}$은 $p=5$, $q=3$인 예시입니다.\n풀이 먼저, $p\u0026gt;q$임을 캐치합시다. 구간 $P$는 항상 구간 $Q$의 왼쪽에 붙어있기 때문에, $p\\leq q$라면, 항상 구간 $P$의 합은 구간 $Q$의 합보다 작습니다.","title":"BOJ 5647 - 연속 합"},{"content":"2023/7/16 일\n우리의 뇌는 자극 즉, 전기신호에 반응하는 함수적인 기능을 수행한다. 그러나 강한 자극을 여러 번 받는다면, 우리의 뇌는 점점 그 자극에 둔감해지고, 더 큰 자극을 추구하게 된다. 이에 대한 적절한 예시가 하나 있다. 요즘은 이른바 \u0026lsquo;숏폼\u0026rsquo; 문화가 유행이라고 한다. 짦은 동영상 공유 플랫폼인 \u0026lsquo;틱톡\u0026rsquo;의 성공 이후, 많은 플랫폼이 1분 남짓 짧은 세로 영상을 공유하는 문화를 적극 밀어주는 추세다. 유튜브의 \u0026lsquo;쇼츠\u0026rsquo;, 인스타그램의 \u0026lsquo;릴스\u0026rsquo;, 심지어 뉴스 플랫폼인 네이버 뉴스도 숏폼을 개설하였다.\n바쁜 현대사회에서는 누구나 정보를 간략하고 밀도 있게 습득하는 것을 선호한다. 당장 인터넷만 봐도 장문의 글에 \u0026ldquo;세 줄 요약 좀.\u0026ldquo;이라는 댓글이 달리는 것을 어렵지 않게 찾아볼 수 있다. 어찌 보면 당연할 수도 있다. 현대인의 시간은 한정되어 있고, 한정된 시간 안에 지적 호기심을 채우기 위해서는 간략하고 밀도가 높은 정보가 필요하다. 그러나 나는 조금 다르게 생각한다. 정보를 습득하는 데만 목적을 두는 것이 아니고, 수용한 정보를 가지고 어떻게 발전해 나갈지도 그에 못지않게 중요하고 본다. 정보를 일방적으로 수용하기만 해서는 도움이 되지 않는다. 사람들이 옛날부터 TV를 \u0026lsquo;바보상자\u0026rsquo;라고 불러왔던 이유를 생각해 보자. TV를 가만히 보다 보면, 수많은 장면이 짧은 시간 안에 교차하고, 그에 따라 주제와 제공하는 정보도 바뀐다. 광고가 나오는 시간을 제외하고는 잠시도 쉴 틈을 주지 않는다. TV 시청자는 정보를 일방적으로 수용하기만 할 뿐, 비판적이고 능동적으로 받아들일 수 없다. 또한, 장면들이 빈번하게 교차하는 것은 시청자들이 산만하게 하고, 집중력, 특히 최대 집중 가능한 시간을 떨어뜨린다.\n숏폼은 TV의 치명적인 문제점을 극대화한 형태를 띠는데, 1분이라는 짧은 시간 안에 많은 정보를 압축하다 보니, 텍스트 간 간격도 없다시피 하고 화면 전환도 더 빠르고 심지어는 많은 정보를 생략하기까지 한다. 가장 큰 문제점은 대부분의 숏폼 플랫폼에서는 영상이 끝나면 바로 다음 영상으로 전환해 준다는 것이다. 숏폼 시청자는 단지 1분 동안 정보를 얻고, 바로 잊어버리고, 다시 다른 정보를 얻고 잊는 과정을 반복할 뿐이다. 이러한 점에서 숏폼은 TV보다 더 유기성이 없고 더 자극적이고 산만하다.\n이러한 자극적인 콘텐츠에 우리의 뇌가 빈번하게 노출되면 어떻게 될까? 뇌는 결국 자극에 익숙해진 상태로 작동하게 되는데, 이를 \u0026lsquo;팝콘 브레인\u0026rsquo; 현상이라고 한다. 팝콘 브레인 현상은 주로 과도한 디지털 기기의 사용으로부터 야기되며, 뇌가 덜 성숙한 유아 및 청소년층에게 더 발생하기 쉽다. 팝콘 브레인 현상은 집중력 저하와 불안 등의 원인이 되고, 특히 요즘 젊은 세대의 문해력 저하 및 반지성주의적 성향의 증가 등이 이 현상으로부터 비롯된다고 한다. 문해력 논란과 반지성주의는 각각 2부 3부에서 자세히 다루도록 하겠다.\n그렇다면 우리는 21세기 정보화 시대에서 어떤 매체를 통해 정보를 습득해야 할까? 나는 자극적인 매체를 멀리하고, 글을 읽는 것이 유일한 해결책이라고 생각한다. 글은 시간이 지난다고 해서 정보가 사라지는 것도 아니고, 만약 글을 읽다가 어려움을 느끼면 다시 읽거나, 문맥을 통해 이해에 도움을 받을 수도 있다. 글은 자극적이지도 않다. 자신의 독서 능력에 맞게 속도도 조절할 수 있다. 마지막으로 독서의 가장 큰 이점은 능동적인 사람이 되기 위해 필수적인 이해 추론 비판 능력을 길러준다는 것이다. 독서의 중요성은 시대를 막론하고 항상 강조되어 왔다. 그럼에도 불구하고 우리나라의 성인 인구의 대부분은 책을 읽지 않는다. 나는 우리나라의 이러한 현실에 통탄할 뿐이다. 전자책도 종이책도 좋다. 독서를 습관화하자.\n(2023/7/15 23:03 추가) 담배회사는 건강을 해친다는 이유로 수많은 세금을 낸다. 틱톡, 유튜브 등은 자기들의 이익을 위해 수많은 사람들의 뇌를 해치는데, 그에 상응하는 세금을 내야 하지 않을까? 당장 보이지 않는다고 뇌 건강을 등한시했다간 흡연보다 더 심한 사회 문제가 발생할지도 모른다.\n오래전에 쓴 글입니다. 총 3부작으로 기획했고, 2부는 이미 작성하고 다듬는 중입니다. 블로그를 옮긴 기념으로 묵혀뒀던 글을 하나 꺼내봅니다.\n","permalink":"http://localhost:1313/posts/popcorn-brain/","summary":"2023/7/16 일\n우리의 뇌는 자극 즉, 전기신호에 반응하는 함수적인 기능을 수행한다. 그러나 강한 자극을 여러 번 받는다면, 우리의 뇌는 점점 그 자극에 둔감해지고, 더 큰 자극을 추구하게 된다. 이에 대한 적절한 예시가 하나 있다. 요즘은 이른바 \u0026lsquo;숏폼\u0026rsquo; 문화가 유행이라고 한다. 짦은 동영상 공유 플랫폼인 \u0026lsquo;틱톡\u0026rsquo;의 성공 이후, 많은 플랫폼이 1분 남짓 짧은 세로 영상을 공유하는 문화를 적극 밀어주는 추세다. 유튜브의 \u0026lsquo;쇼츠\u0026rsquo;, 인스타그램의 \u0026lsquo;릴스\u0026rsquo;, 심지어 뉴스 플랫폼인 네이버 뉴스도 숏폼을 개설하였다.","title":"문해력 이슈 #1 - \"팝콘 브레인\""},{"content":"Intro 등비수열 $a_{n} = ar^{n-1}$의 합은 $$ S_n = \\begin{cases} an \u0026amp;\\text{if } r=1\\ \\newline \\frac{a(r^n - 1)}{r-1} \u0026amp;\\text{otherwise} \\end{cases} $$ 로 나타낼 수 있습니다.\n$r=1$일 때 $S_n$이 다른 이유는, $\\frac{a(r^n - 1)}{r-1}$의 분모가 $0$이 되기 때문입니다.\n이때는, $1$항부터 $n$항까지가 모두 $a$로 같으니, 간단하게 $an$으로 나타낼 수 있습니다.\n$n$이 커지면 커질 수록 $S_n$은 (말 그대로) 기하급수적으로 커지기 때문에, 일반적으로 PS에서는 $S_n$을 $m$으로 나눈 나머지를 구하도록 합니다.\n따라서, 이 글에서는 등비수열의 합 $S_n\\ \\textrm{mod}\\ m$을 빠르게 구할 방법을 소개하겠습니다.\n모듈로 곱셈 역원 ($m$은 소수) 정수 $a$와 소수 $p$에 대하여, $a$와 $p$가 서로소일 때, 법 $p$에 대하여 $a$의 곱셈 역원 $a^{-1}$이 유일하게 존재합니다.\n즉, $aa^{\\prime} \\equiv 1\\ (\\textrm{mod}\\ p)$을 만족하는 역원을 $a^{-1}$라고 합니다.\n그렇다면, 페르마의 소정리 $$ a^{p-1} \\equiv 1\\enspace\\ (\\textrm{mod}\\ p) $$ 를 이용하여 이 역원을 구해봅시다.\n양변에 $a^{-1}$을 곱하면, $a^{p-2} \\equiv a^{-1}\\ (\\textrm{mod}\\ p)$가 됩니다.\n$a$의 역원 $a^{-1}$을 양변에 곱하는 것과 양변에 $a$를 나누는 것이 같음을 보일 수 있지만, 증명은 생략하겠습니다. (증명이 궁금하다면, 이미 구글에도 좋은 자료가 많고, 정수론 책을 찾아봐도 좋습니다.)\n조금 어려울 수도 있지만, 이런 게 있다는 정도만 알고 넘어갑시다.\n따라서, 등비수열의 합 $S_n = \\frac{a(r^n - 1)}{r-1}$은 법 $m$에 대해 $S_n \\equiv a(r^n -1)(r - 1)^{m - 2}\\ (\\textrm{mod}\\ m)$으로 나타낼 수 있습니다.\n페르마의 소정리를 이용하여 역원을 구하면 나눗셈을 곱셈으로 바꿀 수 있어서 편리하지만, 지수가 너무 커져서 거듭제곱 계산에 많은 시간이 들어갈 것으로 보입니다.\n하지만, 여기서 $a^b\\ \\textrm{mod}\\ c$를 빠르게 계산할 수 있는 테크닉이 있습니다.\n바로 \u0026lsquo;분할 정복을 이용한 거듭제곱\u0026rsquo;이라고 하는 테크닉인데요, $$ a^n = \\begin{cases} a^{\\frac{n}{2}} \\times a^{\\frac{n}{2}} \u0026amp; \\textrm{if } n\\textrm{ is odd}\\ \\newline a^{\\lfloor \\frac{n}{2} \\rfloor} \\times a^{\\lfloor \\frac{n}{2} \\rfloor} \\times a \u0026amp; \\textrm{if } n\\textrm{ is even} \\end{cases} $$ 위와 같이 $a^n$의 지수를 반으로 쪼개고, 구한 값을 바탕으로 다시 합치면, 거듭제곱 계산을 $\\mathcal{O}(n)$에서 $\\mathcal{O}(\\lg n)$으로 줄일 수 있습니다! (여기서 $\\lg$는 밑이 $2$인 로그, $\\log _{2}$를 의미합니다.)\n따라서, $m$이 소수일 때에는 분할 정복을 이용한 거듭제곱을 이용하여, $S_n\\ \\textrm{mod}\\ m$을 $\\mathcal{O}(\\lg n)$에 구할 수 있습니다.\n분할 정복 $m$이 만약 소수가 아니라면 어떨까요? 아쉽게도 여기서는 모듈로 곱셈 역원을 구하는 방법을 사용할 수 없습니다.\n$a$와 $m$이 서로소가 아니라면, $aa^{\\prime} \\equiv 1\\ (\\textrm{mod}\\ m)$을 만족하는 역원이 존재할 수 없기 때문입니다.\n증명은 마찬가지로 생략하겠습니다.\n따라서, 합 공식을 사용하는 것은 불가능해보이고, 모든 항을 일일이 더하기에는 너무 느릴 것 같습니다.\n그렇다면 $S_n$의 정의로 돌아가볼까요? $$ \\begin{align*} S_n \u0026amp; = a_1 + a_2 + \\cdots + a_n\\ \\newline \u0026amp; = a + ar + ar^2 + \\cdots + ar^{n-1} \\end{align*} $$ 사실 $S_n$은 제 $1$항부터 $n$항까지 더한다는 기호일 뿐인데, 많은 사람들이 $S_n$의 정의를 그냥 지나치고, 합 공식만 활용하려고 하는 모습을 저는 많이 봐왔습니다. 본질로 돌아가 봅시다.\n$S_n$을 풀어 헤쳐봤으니, 등비수열의 성질을 이용해 식을 간략하게 만들어봅시다.\n먼저, $n$이 짝수일 때에는, $$ \\begin{align*} S_n \u0026amp; =a+ar+ar^2+\\cdots+ar^{n-1}\\ \\newline \u0026amp; =(a+ar+\\cdots+ar^{\\frac{n}{2}-1})+(ar^{\\frac{n}{2}}+ar^{\\frac{n}{2}+1}+\\cdots+ar^{n-1})\\ \\newline \u0026amp; =(a+ar+\\cdots+ar^{\\frac{n}{2}-1})+ r^{\\frac{n}{2}}(a+ar+\\cdots+ar^{\\frac{n}{2}-1})\\ \\newline \u0026amp; =(a+ar+\\cdots+ar^{\\frac{n}{2}-1})(1+r^{\\frac{n}{2}})\\ \\newline \u0026amp; =S_{\\frac{n}{2}}\\cdot (1+r^{\\frac{n}{2}}) \\end{align*} $$ 이렇게 식의 규모를 딱 반으로 줄일 수 있습니다. 식이 반씩 줄어드니, 시간복잡도는 $\\mathcal{O}(n)$에서 $\\mathcal{O}(\\lg n)$로 줄어들겠네요.\n$(1+r^{\\frac{n}{2}})$는 따로 \u0026lsquo;분할 정복을 이용한 거듭제곱\u0026rsquo;을 통해 $\\mathcal{O}(\\lg n)$에 구할 수 있습니다.\n$n$이 홀수일 때에는 $S_n$을 정확히 반으로 묶어낼 수 없으므로, $$ \\begin{align*} S_n \u0026amp; =(a+ar+\\cdots+ar^{n-2})+ar^{n-1}\\ \\newline \u0026amp; =S_{n-1}+ ar^{n-1} \\end{align*} $$ 으로 정리하고, $n-1$은 짝수이므로, $S_{n-1}$은 위의 짝수일 때의 경우를 이용하여 똑같이 처리하고, $ar^{n-1}$ 역시 \u0026lsquo;분할 정복을 이용한 거듭제곱\u0026rsquo;을 통해 $\\mathcal{O}(\\lg n)$에 구할 수 있습니다.\n즉, $S_n$을 분할 정복을 이용하여 구하려면, $$ S_n = \\begin{cases} S_{n-1}+ ar^{n-1} \u0026amp; \\textrm{if } n\\textrm{ is odd}\\ \\newline S_{\\frac{n}{2}}\\cdot (1+r^{\\frac{n}{2}}) \u0026amp; \\textrm{if } n\\textrm{ is even} \\end{cases} $$ 으로 표현할 수 있고, 시간복잡도는 $\\mathcal{O}(\\lg n)$이 됩니다!\n요약 $m$이 소수라면? $S_n \\equiv a(r^n -1)(r - 1)^{m - 2}\\ (\\textrm{mod}\\ m)$ 이용.\n$m$이 소수인지에 관계없이, $$ S_n = \\begin{cases} S_{n-1}+ ar^{n-1} \u0026amp; \\textrm{if } n\\textrm{ is odd}\\ \\newline S_{\\frac{n}{2}}\\cdot (1+r^{\\frac{n}{2}}) \u0026amp; \\textrm{if } n\\textrm{ is even} \\end{cases} $$ 을 이용하여 $S_n\\ \\textrm{mod}\\ m$을 $\\mathcal{O}(\\lg n)$에 구할 수 있습니다!\n연습문제 BOJ 30413 - 양 한 마리\u0026hellip; 양 A마리\u0026hellip; 양 A제곱마리\u0026hellip;\n등비수열의 합을 $10^9+7$로 나눈 나머지를 구하는 문제입니다. 문제 조건에서, 춘배는 똑똑해서 $10^9+7$이 소수임을 알고 있다고 하니, 페르마의 소정리를 활용하여 쉽게 구할 수 있겠습니다. $r=1$인 상황을 주의합시다.\nBOJ 15712 - 등비수열\n이번에는 문제 입력으로 들어오는 $\\textrm{mod}$가 소수라는 보장이 없습니다! 분할 정복으로 빠르게 구해봅시다.\nBOJ 1160 - Random Number Generator\n점화식 $X_{n+1} = (aX_n + c) \\mod m$을 직접 전개하다 보면 중간에 등비수열이 하나 보입니다. 역시 $m$이 소수라는 보장이 없기 때문에, 분할 정복으로 합을 구해봅시다.\n","permalink":"http://localhost:1313/posts/fast-geometric-sequence-sum/","summary":"Intro 등비수열 $a_{n} = ar^{n-1}$의 합은 $$ S_n = \\begin{cases} an \u0026amp;\\text{if } r=1\\ \\newline \\frac{a(r^n - 1)}{r-1} \u0026amp;\\text{otherwise} \\end{cases} $$ 로 나타낼 수 있습니다.\n$r=1$일 때 $S_n$이 다른 이유는, $\\frac{a(r^n - 1)}{r-1}$의 분모가 $0$이 되기 때문입니다.\n이때는, $1$항부터 $n$항까지가 모두 $a$로 같으니, 간단하게 $an$으로 나타낼 수 있습니다.\n$n$이 커지면 커질 수록 $S_n$은 (말 그대로) 기하급수적으로 커지기 때문에, 일반적으로 PS에서는 $S_n$을 $m$으로 나눈 나머지를 구하도록 합니다.\n따라서, 이 글에서는 등비수열의 합 $S_n\\ \\textrm{mod}\\ m$을 빠르게 구할 방법을 소개하겠습니다.","title":"등비수열의 합을 빠르게 구하기"},{"content":"테스트 입니다. 블로그를 옮겼습니다. 기존 블로그는 더 이상 사용하지 않습니다.\n지금 사용중인 theme은 KaTeX 지원을 한다고 들었습니다.\n해보니까 안 돼서 직접 넣었습니다\u0026hellip;\n$$ \\sin x = \\sum _{n=0}^{\\infty} \\frac{(-1)^n x^{2n+1}}{(2n+1)!} $$\n등비수열 $ a_{n} = ar^{n-1} $의 합은 어쩌구\n잘 되네요.\nCode block과 Syntax highlighting 테스트\n1 2 3 4 5 6 7 8 9 10 fn miller_robin(n: u64, a: u64) -\u0026gt; bool { if a % n == 0 { return true; } let mut k = n - 1; loop { let temp = fexp(a as u128, k as u128, n as u128) as u64; if temp == n - 1 { return true; } if k \u0026amp; 1 == 1 { return temp == 1 || temp == n-1; } k \u0026gt;\u0026gt;= 1; } } 만족스럽습니다.\n이제 글 작성에 필요한 것들은 잘 세팅이 되었네요. 앞으로 유익하고 도움이 되는 글들로 돌아오겠습니다. 감사합니다.\n","permalink":"http://localhost:1313/posts/test-post/","summary":"테스트 입니다. 블로그를 옮겼습니다. 기존 블로그는 더 이상 사용하지 않습니다.\n지금 사용중인 theme은 KaTeX 지원을 한다고 들었습니다.\n해보니까 안 돼서 직접 넣었습니다\u0026hellip;\n$$ \\sin x = \\sum _{n=0}^{\\infty} \\frac{(-1)^n x^{2n+1}}{(2n+1)!} $$\n등비수열 $ a_{n} = ar^{n-1} $의 합은 어쩌구\n잘 되네요.\nCode block과 Syntax highlighting 테스트\n1 2 3 4 5 6 7 8 9 10 fn miller_robin(n: u64, a: u64) -\u0026gt; bool { if a % n == 0 { return true; } let mut k = n - 1; loop { let temp = fexp(a as u128, k as u128, n as u128) as u64; if temp == n - 1 { return true; } if k \u0026amp; 1 == 1 { return temp == 1 || temp == n-1; } k \u0026gt;\u0026gt;= 1; } } 만족스럽습니다.","title":"Test Post"}]